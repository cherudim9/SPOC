#lab0 SPOC思考题 - 答案

##funcall

###funcall中的堆栈有多大？是内核态堆栈还是用户态堆栈

128MB-4MB-代码长度-数据区大小。内核态（根据debugger的消息提示可判断）。

###funcall中的全局变量ret放在内存中何处？如何对它寻址？

代码和字符串后面。（0x0000 00a6）

用`xpc-tpc+(ir>>8)`寻址。

###funcall中的字符串放在内存中何处？如何对它寻址？

放在代码后面。（0x0000 0090）

用`xpc-tpc+(ir>>8)`寻址。

###局部变量i在内存中的何处？如何对它寻址？
当进入`write`函数块后，执行了`ENT -8`指令，分配了一个64位的栈空间给`i`（虽然实际上变量`i`只需要32位的空间），之后通过`*(sp+4)`访问`i`。

###当前系统是处于中断使能状态吗？

不在。（根据debugger的消息提示可判断）

###funcall中的函数参数是如何传递的？函数返回值是如何传递的？
在使用JSR调用函数之前，先把所有参数（按从右到左）用`PSHA`之类的压栈指令把参数放到栈中；

函数执行结束后，返回值放在寄存器`a`中。

###分析并说明funcall执行文件的格式和内容

- 00000000~00000003: Magic Number 0xC0DEF00D
- 00000004~00000007: bss，代码区的长度
- 00000008~0000000b: entry，代码的入口位置（即main函数的定义）
- 0000000c~0000000f: flags，值为0
- 00000010~0000009c: 代码内容
- 000000a0~000000b4: 字符串常量

#OS1.c

###何处设置的中断使能？

当执行到C代码中`asm(STI）`的时候，打开了中断使能；之前是关闭的。

###系统何时处于中断屏蔽状态？

两种情况：

1. 在执行到C代码中的`asm(STI）`之前；
2. 处理时钟中断的时候。

###如果系统处于中断屏蔽状态，如何让其中断使能？

使用`STI`（当且仅当无中断时被调用）或者`RTI`指令。

###系统产生中断后，CPU会做哪些事情？（在没有软件帮助的情况下）

在`em.c`的`interrupt:`标记下，可以看到CPU做了以下事情：

1. 从用户栈切换到内核栈；
2. 更换快表（`tr`设置为`trk`，`tw`设置为`twk`）；
3. 把当前的`pc`压栈（为了备份）；
4. 把当前的异常编号`trap`压栈（为了备份）；
5. 修改`pc`到异常处理向量`ivec`处。

###CPU执行RTI指令的具体完成工作是哪些？

1. 判断先决条件：处在内核态；
2. 从内核栈切换到用户栈；
3. 更换快表（`tr`设置为`tru`，`tw`设置为`twu`）；
4. 从栈中获取之前保存的异常处`pc`；
5. 从栈中获取之前保存的异常编号`trap`；
6. 重新打开终端使能。

#os1/os3.c

###os1中的task1和task2的堆栈的起始和终止地址是什么？


`task0`的起始地址是128MB-4MB-代码长度-数据长度；终止地址是代码长度+数据长度。

`task1`的起始地址是`task1_stack+50`；终止地址是`task1_stack`。

###os1是如何实现任务切换的？

- `task0_sp`存着任务零context的`sp`栈顶指针；
- `task1_sp`存着任务一context的`sp`栈顶指针；

每当发生时钟中断的时候，就会调用`alltraps()`异常处理函数，接着调用`trap()`函数。

在`trap()`函数内，（不妨假设现在执行着任务零），会把当前的`sp`存到`task0_sp`内，然后把`sp`恢复为`task1_sp`。从而完成了堆栈的切换。（具体操作可参考`swtch()`函数）


###os3中的task1和task2的堆栈的起始和终止地址是什么？

1. 在内核态内，task0的栈起始地址是`&task0_kstack[1000]`，终止地址是`&task0_kstack[0]`；
2. 在用户态内，task0的栈起始地址是`&task0_stack[1000]`，终止地址是`&task0_stack[0]`；
3. 在内核态内，task1的栈起始地址是`&task1_kstack[1000]`，终止地址是`&task1_kstack[0]`；
4. 在用户态内，task1的栈起始地址是`&task1_stack[1000]`，终止地址是`&task1_stack[0]`；

###os3是如何实现任务切换的？

一开始`main()`函数中，对于每个任务做了这样的事情：初始化该任务的内核栈`taskX_stack`。里面从底到顶分别放了：

1. `task()`函数入口；
2. fault code (USER)；
3. `a,b,c`的值；
4. `task()`函数的用户栈；
5. `trapret()`函数的入口。

接着，调用`LEV`命令后，设置了当前的`pc`为`trapret()`的入口。然后在`trapret()`函数内发生了这些事情：

1. 上一段中的第四点（"`task()`函数的用户栈"）被出栈并放入`usp`寄存器中；
2. 上一段中的第三点中的`a,b,c`被依次出栈；
3. 执行`RTI`指令。上一段中的第二点中的fault code被恢复并用于判断；从中断/异常返回时，进入`task()`函数入口。

从而第一次进入了`task0`。

接着就和os1的情况一样了——每当时钟中断，就切换两个任务的栈，从而达到任务切换。


###os3的用户态task能够破坏内核态的系统吗？

不能。用户态task能操作的内存空间直接上都是原程序的全局变量（`task0_stack`、`task0_kstack`、`task1_stack`、`task1_kstack`）
